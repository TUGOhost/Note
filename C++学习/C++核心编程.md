# C++核心编程

主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。

## 1.内存分区模型

C++程序在执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收



内存四区意义：

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程



### 1.1 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

**代码区**：

- 存放CPU执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令

**全局区**：

- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量（const修饰的全局变量）也存放在此
- 该区域的数据在程序结束后由操作系统释放

### 1.2 程序运行后

**栈区**：

- 由编译自动分配释放，存放函数的参数值、局部变量等

注意事项：不要返回局部变量的地址，因为栈区开辟的数据由编译器自动释放

**堆区**

- 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

在C++中主要利用new在堆区开辟内存

### 1.3 new操作符

C++中利用new操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete

语法：`new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针

## 引用

### 2.1引用的基本使用

作用：给变量起别名

语法：`数据类型 &别名= 原名`

### 2.2 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变

### 2.3 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

### 2.4 引用做函数的返回值

作用：引用可以作为函数的返回值存在的

注意：不要返回局部变量音乐

用法：函数调用作为左值

### 2.5引用的本质

本质：引用的本质在C++内部实现一个指针常量

### 2.6 常量引用

作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加const修饰形参，防止形参改变实参

## 3 函数提高

### 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：`返回值类型 函数名(参数 = 默认值){}`

注意事项：

1. 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值
2. 如果函数的声明有默认参数，函数实现就不能有默认参数。声明和实现只能有一个有默认参数

### 3.2 函数占位参数

C++中函数的形参列表里可以占位参数，用来做占位，调用函数时必须填补该位置

语法：`返回值类型 函数名(数据类型){}`

### 3.3 函数重载

#### 3.3.1 函数重载概述

作用：函数名可以相同，提高复用性

函数重载满足条件：

- 同一个作用域下
- 函数名称相同
- 函数参数类型不同 或者 个数不同 或者 顺序不同

注意：函数的返回值不可以作为函数重载的条件

#### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

## 4 类和对象

C++面向对象的三大特性为：封装、继承、多态

C++ 认为万事万物都皆为对象，对象上有其属性和行为

### 4.1 封装

#### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

封装意义一：

​	在设计类的时候，属性和行为写在一起，表现事物

语法：`class 类名{ 访问权限: 属性 / 行为};`

示例：

```c++
#include <iostream>

using namespace std;

const double PI = 3.14;

class Circle
{

public:
    // 半径
    int m_r;

    //获取圆的周长
    double calculate()
    {
        return 2 * m_r * PI;
    }
};

int main()
{
    // 通过圆类 创建具体的圆
    Circle circle;
    circle.m_r = 10;
    cout << " 圆的周长： " << circle.calculate() << endl;
}
```

封装意义二：

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public 公共权限 成员 类内可以访问 类外可以访问
2. protected 保护权限 成员 类内可以访问 类外不可以访问 儿子可以访问父亲中的保护内容
3. private  私有权限 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲的私有内容

#### 4.1.2 struct和class区别

在C++中struct和class唯一的区别就在于默认的访问权限不同

区别：

- struct默认权限为公共
- class默认权限为私有

#### 4.1.3 成员属性设置为私有

优点：

- 将所有成员属性设置为私有，可以自己控制读写权限
- 对于写权限，我们可以检测数据的有效性

### 4.2 对象的初始化和清理

- 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
- C++中的面向对象来源与生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

#### 4.2.1 构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。



- 构造函数：主要作用在于创建对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
- 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作



构造函数语法：`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次



析构函数语法：`~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

示例：

```c++
#include <iostream>

using namespace std;

class Person
{   
public:
    Person()
    {
        cout << "Person 构造函数的调用" << endl;
    }
    ~Person()
    {
        cout << "Person 析构函数的调用 " << endl;
    }
};

int main()
{
    Person person;
}
```

#### 4.2.2 构造函数的分类及调用

两种分类方式：

- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

三种调用方式：

- 括号法
- 显示法
- 隐式转换法

示例：

```c++
#include <iostream>

using namespace std;

class Person
{   
public:
    Person()
    {
        cout << "Person 无参构造函数的调用" << endl;
    }

    Person(int a)
    {
        age = a;
        cout << "Person 有参构造函数的调用" << endl;
    }


    //拷贝构造函数
    Person(const Person &person)
    {
        age = person.age;
        cout << "Person 拷贝构造函数的调用" << endl;
    }

    ~Person()
    {
        cout << "Person 析构函数的调用 " << endl;
    }

private:
    int age;
};

int main()
{
    //括号法
    Person p; //默认构造函数的调用
    Person p2(10); // 有参构造函数的调用
    Person p3(p2); // 拷贝构造函数的调用

    // 调用默认构造函数不要是加()
    // 因为下面的代码，编译器会认为是一个函数的声明，不会认为在创建对象
    //Person p(); 

    //显示法
    Person p21;
    Person p22 = Person(10);
    Person p23 = Person(p22);

    Person(10); // 匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象

    // 不要利用拷贝构造函数 初始化匿名对象 编译器会认为Person (p23) === Person p23; 对象的声明
    //Person(p23);

    //隐式转换法

    Person p4 = 10; // 相当于 写了 Person p4 = Person(10);
    Person p5 = p4; // 拷贝构造
}
```

#### 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况：

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

示例：

```c++
#include <iostream>

using namespace std;

class Person
{
public: 
    Person()
    {
        cout << "Person 无参构造函数的调用" << endl;
    }

    Person(int a)
    {
        age = a;
        cout << "Person 有参构造函数的调用" << endl;
    }

    Person(const Person &person)
    {
        age = person.age;
        cout << "Person 拷贝构造函数的调用" << endl;
    }

    ~Person()
    {
        cout << "Person 析构函数的调用 " << endl;
    }

private:
    int age;
};

void doWork(Person p)
{

}

Person doWork1()
{
    Person p1;
    return p1;
}

int main()
{
    // 使用一个已经创建完毕的对象来初始化一个新对象
    Person p1(20);
    Person p2(p1);

    // 值传递的方式给函数参数传值
    doWork(p1);

    // 以值方式返回局部对象
    Person p3 = doWork1();
}
```

#### 4.2.4 构造函数的调用规则

默认情况下，C++编译器至少给一个类添加3个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

#### 深拷贝与浅拷贝

深拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的复制拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

示例：

```c++
#include <iostream>

using namespace std;

class Person
{
public: 
    Person()
    {
        cout << "Person 无参构造函数的调用" << endl;
    }

    Person(int a, int h)
    {
        age = a;
        height = new int(h);
        cout << "Person 有参构造函数的调用" << endl;
    }

    Person(const Person &person)
    {
        age = person.age;
        cout << "Person 拷贝构造函数的调用" << endl;
    }

    // 自己实现拷贝构造函数 解决浅拷贝带来的问题
    Person(const Person &p)
    {
        cout << "Person 拷贝构造函数调用" << endl;
        age = p.age;
        //height = p.height; // 浅拷贝，编译器提供的拷贝构造函数
        height = new int(*p.height); // 深拷贝
    }

    ~Person()
    {
        // 析构函数，将堆区开辟数据做释放操作
        if (height != NULL)
        {
            delete height;
            height = NULL;
        }
        cout << "Person 析构函数的调用 " << endl;
    }

private:
    int age;
    int *height;
};

void test01()
{
    Person p1(18, 160);

    Person p2(p1);
}

int main()
{
    test01();
}
```

#### 4.2.6 初始化列表

作用：C++提供了初始化列表语法，用来初始化属性

语法：`构造函数(): 属性1(值1) 属性2(值2)...{}`

#### 4.2.7 类对象作为类成员

C++类中的成员是另一个类的对象，我们称该成员为 对象成员

例如：

```c++
class A{}

class B
{
    A a;
}
```

B类中有对象A作为成员，A为对象成员

那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

构造顺序：先构造其他类对象，再构造自身。

析构顺序：与构造顺序相反

#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，成为静态成员

静态成员分为：

- 静态成员变量
  - 所有对象共享一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量

示例：

```c++
#include <iostream>

using namespace std;


class Person
{
public:
    static int a;

    static void func()
    {
        cout << "静态成员函数" << endl;
    }

private:
    static int b;
};


int Person::a = 100;
int Person::b = 200;
int main()
{
    Person p;
    cout << p.a << endl;
    //通过对象
    //p.func();
    //p.a = 200;
    //cout << p.a << endl;
    // 通过类名
    Person::func();
}
```

### 4.3 C++对象模型和this指针

#### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

#### 4.3.2 this指针

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？



C++ 通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可是用return *this

#### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

#### 4.3.4 const修饰成员函数

常函数：

- 成员函数后加const后我们称为这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

常对象

- 声明对象前加const称该对象为常对喜爱那个
- 常对象只能调用常函数

### 4.4. 友元

友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为friend

友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

### 4.5 运算符冲在

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算

```c++
#include <iostream>

using namespace std;

class Person
{
public:
    int a;
    int b;
};
// 全局函数重载
Person operator+(Person &p1, Person &p2)
{
    Person tmp;
    tmp.a = p1.a + p2.a;
    tmp.b = p1.b + p2.b;
    return tmp;
}

int main()
{
    Person p1;
    p1.a = 1;
    p1.b = 2;

    Person p2;
    p2.a = 1;
    p2.b = 2;

    cout << "p1 + p2  a = " << (p1 + p2).a << endl;
    cout << "p1 + p2  b = " << (p1 + p2).b << endl;
}
```

#### 左移运算符重载

> void operator<<(ostream &cout, Person p)

#### 递增运算符重载

作用：通过重载递增运算符，实现自己i的整型数据

#### 4.5.4 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数、对属性进行值拷贝
4. 赋值运算符 opertator=，对赋值进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

#### 4.5.5 关系运算符重载

作用：重载关系运算符，可以让两个自定义类型对象进行对比操作

#### 4.5.6 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为伪函数
- 伪函数没有固定写法，非常灵活

### 4.6 继承

继承是面向对象三大特性之一

定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。利用继承的技术，减少重复代码。

#### 4.6.1 继承的基本语法

语法：`class 子类 : 继承方式 父类{}`

#### 4.6.2 继承方式

- 公共继承
- 保护继承
- 私有继承

父类私有方式，子类不管什么继承方式，都是继承不了

子类通过公共继承方式继承父类，那么父类的公共方式、保护方式都可以继承

子类通过保护继承方式继承父类，那么父类的保护方式可以继承

子类通过私有继承方式继承父类，那么父类所有的都继承不了

#### 4.6.3 继承中的对象模型

问题：从父类继承过来的成员，那些属于子类对象？

结论：父类中私有成员也是被子类继承下去了，只是由于编译器给隐藏后访问不到

#### 4.6.4 继承中的构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序是谁先谁后？

结论：父类的构造比子类的构造先，子类的析构比父类的析构先

#### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域

#### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

#### 4.6.7 多集成语法

C++允许一个类继承多个类

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

C++实际开发中不建议用多继承

#### 菱形继承

菱形继承概念：

 两个派生类继承同一个基类

 又有某个类同时继承这两个派生类

 这种继承被称为菱形继承，或者钻石继承

### 4.7 多态

#### 4.7.1 多态的基本概念

多态是C++面向对象三大特性之一

多态分为两类

- 静态多态：函数重载 和 运算重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

动态多态使用：父类的指针或引用 执行子类对象

示例：

```c++
#include <iostream>

using namespace std;

class Animal
{
public:
    // 虚函数 
    virtual void speak()
    {
        cout << "动物在说话" << endl;
    }
};

class Cat : public Animal
{
public:
    // 重写，函数返回值，参数列表，函数名完全一样
    void speak()
    {
        cout << "小猫在说话" << endl;
    }
};

class Dog : public Animal
{
public:
    void speak()
    {
        cout << "小狗在说话" << endl;
    }
};

// 地址早绑定，在编译阶段就确定了函数的地址
void doSpeak(Animal &animal)
{
    animal.speak();
}

int main()
{
    Cat cat;
    doSpeak(cat);

    Dog dog;
    doSpeak(dog);
}
```

#### 4.7.2 纯虚函数和抽象类

 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为纯虚函数

纯虚函数语法：`virtual 返回值类型 函数名(参数列表) = 0;`

当类中有了纯虚函数，这个类也称为抽象类



抽象类特点：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

```c++
#include <iostream>
using namespace std;

// 抽象类
class Base
{
public:
    // 纯虚函数
    virtual void func() = 0;
};

class Son : public Base
{
public:
    void func()
    {}
};

void test01()
{
    Son Son;
}


int main()
{

}
```

#### 4.7.3 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为虚析构或者纯虚析构

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象



虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

`virtual ~类名() = 0`

`类名::~类名(){}`

总结：

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也不属于抽象类

## 5 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过文件可以将数据持久化

C++中对文件操作需要包含头文件\<fstream>

文件类型分为两种：

1. 文本文件 - 文件以文本的ASCII码形式存储在计算机中
2. 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类：

1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作

### 5.1 文本文件

#### 5.1.1 写文件

写文件步骤如下：

1. 包含头文件

   \#include\<fstream>

2. 创建流对象

   ofstream ofs;

3. 打开文件

   ofs.open("文件路径", 打开方式);

4. 写数据

   ofs << "写入数据";

5. 关闭文件

   ofs.close();

文件打开方式：

| 模式标记                          | 适用对象                  | 作用                                                         |
| --------------------------------- | ------------------------- | ------------------------------------------------------------ |
| ios::in                           | ifstream fstream          | 打开文件用于读取数据。如果文件不存在，则打开出错。           |
| ios::out                          | ofstream fstream          | 打开文件用于写入数据。如果文件不存在，则新建该文件；如果文件原来就存在，则打开时清除原来的内容。 |
| ios::app                          | ofstream fstream          | 打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件。 |
| ios::ate                          | ifstream                  | 打开一个已有的文件，并将文件读指针指向文件末尾（读写指 的概念后面解释）。如果文件不存在，则打开出错。 |
| ios:: trunc                       | ofstream                  | 打开文件时会清空内部存储的所有数据，单独使用时与 ios::out 相同。 |
| ios::binary                       | ifstream ofstream fstream | 以二进制方式打开文件。若不指定此模式，则以文本模式打开。     |
| ios::in \| ios::out               | fstream                   | 打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| ios::in \| ios::out               | ofstream                  | 打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| ios::in \| ios::out \| ios::trunc | fstream                   | 打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件。 |

注意：文件打开方式可以配合使用，利用|操作符

示例：

```c++
#include <iostream>
#include <fstream>

using namespace std;

void test01()
{
    ofstream ofs;

    ofs.open("test.txt", ios::out);

    ofs << "Hello world!";

    ofs.close();
}

int main()
{
    test01();
}
```

