# 继承

### super关键字

```java
public Manager(String name, double salary, int year, int month, int day){
	super(name, salary, year, month, day);
    bonus = 0;
}
```

这里的关键字super具有不同的含义。语句`super(n, s, year, month, day);`是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式。

由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句。

注意区分`this`和`super`关键字。

关键字`this`的两个用途：

1. 引用yin'shi隐式参数
2. 调用该类其他的构造器

关键字`super`的两个用途：

1. 调用超类的方法
2. 调用超类的构造器

`调用构造器的语句只能作为另一个构造器的第一天语句`

### 理解方法调用

1. 编译器查看对象的声明类型和方法名
2. 接下来编译器将查看调用方法时提供的参数类型
3. 至此，编译器已获得需要调用的方法名字和参数类型

### 强制类型转换

在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。

### Object：所有类的超类

Object类是Java中所有类的始祖，在Java中每个类都是由他扩展而来的。

Object类中的equals方法用于监测一个对象是否等于另外一个对象。在Object类中，这个方法判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，他们一定是相等的。

### 对象包装器与自动装箱

这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean（前6个类派生于公共的超类Number）

### 反射

反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。

能够分析类能力的程序成为反射（reflective）

反射机制可以用来：

- 在运行时分析类的能力
- 在运行时查看对象，例如，编写一个toString方法供所有类使用
- 实现通用的数组操作码
- 利用Method对象，这个对象很想C++中的函数指针

Object类中的getClass()方法将会返回一个Class类型的实例。

最常用的Class方法是getName。这个方法将返回类的名字。

Class类实际上是一个泛型类。

newInstance()方法可以用来动态地创建一个类的实例。

#### 捕获异常

当程序运行过程中发生错误时，就会“抛出异常”。抛出异常比终止程序要灵活得多，这是因为可以提供一个“捕获”异常的处理器（handler）对异常情况进行处理。

如果没有提供处理器， 程序就会终止，并在控制台上打印出一条信息，其中给出了异常的类型。可能在前面已经看到过一些异常报告，例如，偶然使用了null引用或者数组越界等。

异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。然而，有很多常见的异常，例如，访问null引用，都属于未检查异常。编译器不会查看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发生，而不要将精力花在编写异常处理器上。

#### 利用反射分析类的能力

在java.long.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。

Class类中地getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。Class类的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。

### 继承的设计技巧

1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“is-a”关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而非类型信息
7. 不要过多地使用反射

# 接口

### 接口

一个类可以实现（implement）一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。

#### 接口概念

在Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

# Java的基本程序设计结构

### 3.2 注释

当需要长篇的注释时，既可以在每行的注释前面标记//，也可以使用`/*`和`*/`将一段比较长的注释括起来。自动生成文档注释，`/**`开始，`*/`结束。

### 3.3 数据类型

整型用于表示没有小数部分的数值



# 集合

### 9.2 具体的集合

![](image/126.png)

除了Map结尾的类之外，其他都实现了Collection接口，而以Map结尾的类实现了Map接口。

#### 链表

在Java程序设计语言中，所有链表实际上都是双向链表的（double linked）——即每个节点还存放着指向前去节点的引用。

![](image/127.png)

从链表中间删除一个元素是一个很轻松的操作， 即需要更新被删除元素附近的链接。

![](image/128.png)

在链表中添加或删除元素时，绕来绕去的指针可能已经给人们留下了极坏的印象。如果真是如此的话，就会为Java集合类库提供一个LinkedList而感到拍手称快。

在下面的代码示例中，先添加3个元素，然后再将第2个元素删除；

```java
List<String> staff = new LinkedList<>();// LinkedList implements List
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Interator iter = staff.iterator();
String first = iter.next();//visit first element
String second = iter.next();//visit second element
iter.remove();//remove last visited element
```

链表是一个有序集合（ordered collection），每个对象的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。由于迭代器时描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。Add方法在迭代器之前添加一个新对象。

当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时（即hasNext返回false），添加的元素将变成列表的新表尾。如果链表由n个元素，由n+1个位置可以添加新元素。这些位置与迭代器的n+1个可能的位置相对应。例如，如果链表包含3个元素，A、B、C，就有四个位置（标有|）可以插入新元素：

> |ABC
>
> A|BC
>
> AB|C
>
> ABC|

**注释**：在用“光标”类比时要格外小心。remove操作与BACKSPACE键的工作方式不太一样。在调用next之后，remove方法确实与BACKSPACE键一样删除了迭代器左侧的元素。但是如果调用previous就会将右侧的元素删除掉，并且不能连续调用两次remove。

add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。

例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该在使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个ConcurrentModificationException异常。

为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

有一个简单的方法可以检测到并发修改的问题。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致，抛出一个ConcurrentModificationException异常。

**注释**：对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。set方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有节点的内容进行修改。

使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用ArrayList。

我们建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayLister，而不要使用链表。

#### 数组列表

#### 散列集

有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表（hash table）。散列表为每个对象计算一个整数，称为散列码（hash code）。散列码是由对象地实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

在Java中，散列表用链表数组实现。每个列表被称为桶（bucket）。![散列表](image/129.png)

要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。当然，有时候会遇到桶被占满的情况，这也是不可避免地。这种现象被称为散列冲突（hash collision）。这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。

**注释**：在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码视图在散列表中填充多个有相同散列码的值，这样就能提高性能。

如果想更多地控制散列表地运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。入宫大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的75%~150%。有些研究人员认为：尽管还没有确凿的证据，但最好将桶数设置为一个素数，以防键的集聚。

如果散列表太满，就需要再散列（rehashed）。如果对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子（load factor）决定何时对散列表进行再散列。

Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。散列表迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问他们的顺序几乎是随机的。

#### 树集

TreeSet类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合（sorted collection）。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。

树地排序必须是全序。也就是说，任意两个元素必须是可比的，并且只有在两个元素相等时结果才为0。

#### 队列与双端队列

队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。有两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。在Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。

#### 优先级队列

优先级队列（priority queue）中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。优先级队列使用了一个优雅且高效的数据结构，称为堆（heap）。堆是一个可以自我调整的二叉树，对树执行添加（add）和删除（remove）操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。

使用优先级队列的典型示例是任务调度。每个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将1设为“最高”优先级，所以会将最小的元素删除）。

### 9.3 映射

集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素，需要有要查找元素的精确副本。这不是一种非常通用的查找方式。通常，我们知道某些键的信息，并想要查找与之对应的元素。映射（map）数据结构就是为此设计的。映射用来存放键/值对。如果提供了键，就能够查找到值。

#### 基本映射操作

Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。

散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数职能作用于键。于键关联的值不能进行散列或比较。

散列稍微快一些，如果不需要按照排序顺序访问键，就最好选择散列。

下列代码将为存储的员工信息建立一个散列映射：

```java
Map<String, Employee> staff = new HashMap<>(); // HashMap implements Map
Employee harry = new Employee("Harry Hacker");
staff.put("987-98-9996", harry);
```

每当往映射中添加对象时，必须同时提供一个键。在这里，键是一个字符串，对应的值是Employee对象。

要想检索一个对象，必须使用（因而，必须记住）一个键。

> String id = "987-98-9996";
>
> e = staff.get(id);

如果在映射中没有与定键对应的消息，get将返回null。null返回值可能并不方便。有时可以有一个好的默认值，用作为映射中不存在的键。然后使用getOrDefault方法。

> Map<String, Integer> scores = ...;
>
> int score = scores.get(id,0); // Gets 0 if the id is not present

键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。

remove方法用于从映射中删除给定键对应的元素。size方法用于返回映射中的元素数。

要迭代处理映射的键和值，最容易的方法是使用forEach方法。

#### 更新映射项

处理映射时的一个难点就是更新映射项。正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。下面来看一个例子，使用一个映射统计一个单词再文件中出现的频度。看到单词（word）时，我们将计数器增1，如下所示：

> counts.put(word, counts.get(word) + 1)

这是可以的，不过一种情况除外：就是第一次看到word时。在这种情况下，get会返回null，因此会出现NullPointerException异常。

作为一个简单的补救，可以使用getOrDefault方法：

> counts.put(word, counts.getOrDefault(word, 0) + 1);

另一个方法是首先调用putIfAbsent方法。只有当键原先存在时才会放入一个值。

> counts.putInfAbsent(word, 0 );
>
> counts.put(word,counts.get(word) + 1);

不过还可以做得更好。merge方法可以简化这个常见的操作。如果键原先不存在，下面的调用：

> counts.merge(word, 1,Integer::sum);

将把word与1关联，否则使用Integer::sum函数组合原值和1（也就是将原值与1求和）。

